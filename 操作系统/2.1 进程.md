<!--
 * @Author: Jerome 841682441@qq.com
 * @Date: 2022-12-11 23:44:48
 * @LastEditors: Jerome 841682441@qq.com
 * @LastEditTime: 2022-12-12 17:52:11
 * @FilePath: \操作系统\2.1 进程.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * 
-->
## 进程

**2.1 进程的基本概念**

程序：指的是一个指令序列
在引入了多到程序技术之后，为了方便操作系统管理，完成各程序并发执行，引入了进程、进程实体的概念。

系统为每个运行的程序配置一个数据结构，成为进程控制块(PCB)，用来描述进程的各种信息(如程序代码存放位置)
**注意:**
PCB、程序段、数据段三部分构成了**进程实体(进程映像)**。一般来说，我们可以把进程实体就简称为进程。例如，所谓创建进程，实质上就是创建进程实体中的PCB。而撤销进程，实质上就是撤销进程实体中的PCB。
PCB是进程存在的唯一定义。

虽然对进程的定义各有不同，但是全都强调其动态性。

在引入进程实体的概念后，可以把进程定义为：
进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
> 严格来说，进程实体和进程不一样，进程实体是静态的，而进程是动态的。

进程的管理者，也即操作系统所需的所有数据都在PCB中。

进程和程序是两个截然不同的概念，相比于程序，进程拥有以下特征：

    1.动态性：进程是程序的一次执行过程，是动态地产生、变化和消亡的。
    2.并发性：内存中有多个进程实体，各进程可以并发执行。
    3.独立性：进程是独立运行、独立获得资源、独立接受调度的基本单位。
    4.异步性：各进程按照各自独立的、不可预知的速度向前推进，操作系统需要提供"进程同步机制"来解决异步问题。
    5.结构性：每个进程都会配置一个PCB。从结构上看，进程由程序段、数据段和PCB组成。


**2.2 进程的状态和转换**

**进程的状态**
三种基本状态：运行状态、就绪状态、阻塞状态
此外还有两种状态：创建状态、终止状态

**三种基本状态**
运行态(Running)：占有CPU，并在CPU上运行
就绪态(Ready)：已经具备运行条件，但是由于没有空闲的CPU，而暂时不能运行
阻塞态(Blocked/Waiting)：因等待某一事件而暂时不能运行

**进程状态的转换**
创建态——>就绪态——>运行态——>阻塞态——>终止态

创建态——>就绪态发生在系统完成创建进程的一系列工作
就续态——>运行态是由于进程被调度
运行态——>就绪态是由于时间片到，或者处理机被抢占
运行态——>阻塞态是一种进程自身作出的主动行为。发生是由于进程用系统调用的方式申请某种系统资源，或者请求等待某个事件发生
阻塞态——>就绪态不是进程自身能够控制的，是一种被动行为。发生是由于申请的资源化被分配，或者等待的事件发生
运行态——>终止态发生在进程运行结束，或者运行过程中遇到不可修复的错误

**注意**：不能由阻塞态直接转换成运行态，也不能由就绪状态直接转换为阻塞态，这是因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求。


**2.3 进程控制**
进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。
简单来说，进程控制就是要实现进程状态的转换

为了防止在进行状态转换的过程中出现未修改PCB的情况，使用原语来实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。
这种不可以被中断的操作即院子操作。
具体的原语采用 关中断指令 和 开中断指令 实现

    ''''''
    关中断指令
    原语代码1
    原语代码2
    开中断指令

在上述开关中断指令之间，外部中断信号会被忽略。
原语运行在核心态中。
>显然，关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令。

**2.4 进程通信**
进程通信可以通过共享存储、消息传递和管道通信来实现。
其中共享存储包含基于数据结构的共享、基于存储区的共享。
消息传递包含直接通信方式和间接通信方式。

进程通信指的是进程之间的信息交换。
进程是分配系统资源的单位(包括有内存地址空间)，因此各进程拥有的内存地址空间相互独立。

为了保证安全，一个进程不能够直接方位另一个进程的地址空间。
但是进程之间的信息交换又是必须实现的，因此为了保证进程间的安全通信，操作系统提供了一些办法。其方法具体可以通过共享存储、消息传递和管道通信来实现。

**1.共享存储**
创建共享空间来实现进程间数据通信。
两个进程对共享空间的访问必须是互斥的(互斥访问通过操作系统提供的工具实现)。
其中共享存储包含基于数据结构的共享、基于存储区的共享。
基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。
基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。


**2.管道通信**
所谓的管道实际上指的是用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓存区。

**注意**
1)管道只能实现半双工通信，如果要实现双向同时通信，则需要设置两个管道。
2)各个进程要互斥地访问管道。
3)数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4)如果管道没写满，就不允许读。如果没读空，就不允许写。
5)数据一旦被读出，就会从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。

**3.消息传递**
进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的"发送消息/接收消息"两个原语进行数据交换。
其中格式化的消息由消息头和消息体两部分组成。消息头中包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息(计算机网络中发送的报文就是一种格式化的消息)

消息传递包含有两种：直接通信方式 和 间接通信方式
其中直接通信方式是消息直接挂到接收进程的消息缓冲队列上。
间接通信方式是消息需要先发送到中间实体(信箱)中，因此也成为"信箱通信方式"。


