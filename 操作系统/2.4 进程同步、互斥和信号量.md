<!--
 * @Author: Jerome 841682441@qq.com
 * @Date: 2022-12-12 17:52:31
 * @LastEditors: Jerome 841682441@qq.com
 * @LastEditTime: 2022-12-13 10:18:39
 * @FilePath: \操作系统\2.4 进程同步、互斥和信号量.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
## 进程同步、进程互斥
**进程同步**
进程具有异步性的特征，异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。
同步又称作是直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。
**进程互斥**
我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备(比如摄像头、打印机)都属于临界资源。此外，还有许多变量、数据、内存缓冲区等都属于临界资源。
对临界资源的访问，必须互斥地进行。互斥，也叫做间接制约关系。进程互斥指的是当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：
1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)。
4.让权等待。当进程不能进入临界区时，应当立即释放处理机，防止进程忙等待。

**1 进程互斥的软件实现方法**
进程互斥的软件实现方法主要有四种：分别是，单标志法、双标志先检查、双标志后检查、Peterson算法

**1.1 单标志法**
算法思想：连个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。

单标志法存在的主要问题是：违背“空闲让进”原则。

**1.2 双标志先检查法**
算法思想：设置一个布尔型数组flag[\]，数组中各个元素用来标记各进程想进入临界区的意愿，比如"flag[0]=true"意味着0号进程现在想要进入临界区。每个进程在进入临界区之前都会先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设置为true，之后开始访问临界区。
双标志先检查法主要的问题是：违反"忙则等待"原则。
原因在于，进入区的检查和上锁两个处理不是一气呵成的。在检查后，上锁前可能发生进程切换。

**1.3 双标志后检查法**
算法思想：双标志先检查法的改版。前一个算法的问题是先检查后上锁，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，在该算法中使用先上锁后检查的方法，来避免上述问题。
双标志后检查法虽然解决了忙则等待问题，但是又违背了空闲让进和优先等待原则，会因各进程都长期无法访问临界资源而产生的饥饿现象。
假如两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。

**1.4 Peterson算法**
算法思想：双标志后检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后无法进入临界区。Peterson想到了一种方法，也就是如果双方都尝试进入临界区，那么就可以让进城主动让对方先使用临界区。
Peterson算法使用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、优先等待三个原则，但是仍然未遵循让权等待的原则。

**2 进程互斥的硬件实现方法**
进程互斥的硬件实现方法：中断屏蔽方法、TestAndSet(TS指令/TSL指令)、Swap指令(XCHG指令)。
**2.1 中断屏蔽方法**
利用开/关中断指令实现(与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不能发生变化两个同时访问临界区的情况)
**优点**：简单、高效
**缺点**：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程(因为开/关中断指令只能运行于内核态，这组指令如果能让用户随意使用会很危险)

**2.2 TestAndSet指令**
简称为TS指令，也有地方称为TestAndSetLock指令，称为TSL指令
TSL指令使用硬件实现的，在执行的过程中不允许被中断，只能一气呵成。
相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的院子操作。
**优点**：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。
**缺点**：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。

**2.3 Swap指令**
有的地方也叫Exchange指令，或简称为XCHG指令。
Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。
**优点**：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境。
**缺点**：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。

