<!--
 * @Author: Jerome 841682441@qq.com
 * @Date: 2022-12-13 10:18:49
 * @LastEditors: Jerome 841682441@qq.com
 * @LastEditTime: 2022-12-16 23:50:25
 * @FilePath: \操作系统\2.5 信号量机制.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
## 信号量机制
信号量机制有两种，分别为整型信号量、记录型信号量。

**1 信号量机制**
之前学习的进程互斥的解决方案大都存在着一些问题。
进程互斥的四种软件实现方式：单标志法、双标志先检查、双标志后检查、Peterson算法。
进程互斥的三种硬件实现方式：中断屏蔽方法、TestAndSet(TS指令/TSL指令)、Swap指令(XCHG指令)。
1.在双标志先检查法中，进入区的检查、上锁操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题。
2.所有的解决方案都无法实现让权等待。

因此，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥、同步的方法————**信号量机制**。

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而可以很方便地实现了进程互斥和进程同步。
信号量其实就是一个变量(可以是一个整数，也可以是更复杂的记录型变量)，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。
**


原语**是一种特殊的程序段，其执行只能一气呵成，不可以被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是进入区的各种操作无法一气呵成，因此如果能把进入区、退出区的操作都用原语来实现，使得这些操作能够一气呵成就能解决问题。
一对原语：Wait(S)原语和Signal(S)原语，可以把原语理解为我们自己写的参数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数。
wait、signal原语简称为P、V操作，因此Wait(S)和Signal(S)两个操作分别写为P(S)、V(S).

**1.1 整型信号量**
用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。
与普通整数变量的区别：
对信号量的操作只有三种，即：初始化、P操作、V操作
存在的问题：不满足让权等待原则。会发生忙等

**1.2 记录型信号量**
整型信号量的缺陷是存在忙等问题，因此人们又提出了记录型信号量，即用记录型数据结构表示的型号量。
在某进程需要使用资源时，通过wait原语申请：
如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列(即阻塞队列)中。
在进程使用完资源后，通过signal原语释放：
释放资源后，如果还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。

通常情况下wait(S)、signal(S)也可以记为P(S)、V(S)，这对源于可用汉语可用于实现系统资源的申请和释放。
S.value的初值表示系统中某种资源的数目。
对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行S.value--，表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此该进程应当调用block原语进行自我阻塞(当前运行的进程从运行态——>阻塞态)，主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了让权等待原则，不会出现忙等现象。
对信号量S的一次V操作意味着进程释放等待一个单位的该类资源，因此需要执行S.value++,表示资源数加1，若加1后仍是S.value<=0，表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程(被唤醒进程从阻塞态——>就绪态)。



**2 用信号量实现进程互斥、同步、前驱关系**
**2.1 信号量机制实现进程互斥**
1.分析并发进程的关键活动，划定临界区(如：对临界资源打印机的访问就应放在临界区)
2.设置互斥信号量mutex，初值为1
3.在临界区之前执行P(mutex)
4.在临界区之后执行V(mutex)

注意：(1)对不同的临界资源需要设置不同的互斥信号量。
(2)P、V操作必须成对出现。缺少P(mutex)就不能保证临界资源的互斥访问。缺少V(mutex)会导致资源永不被释放，等待进程永不被唤醒。

**2.2 信号量机制实现进程同步**
进程同步：要让各并发进程按要求有序地推进。
进程同步问题就是让本来异步并发的进程相互配合，有序推进。

用信号量实现进程同步：
1.分析is很饿没地方需要实现"同步关系"，即必须保证"一前一后"执行得到两个操作(或两句代码)
2.设置同步信号量S,初始维0
3.在“前操作”之后执行V(S)
4.在“后操作”之后执行P(S)

**2.3 信号量机制实现前驱关系**
前驱关系与上面提到的同步关系是一样的，只不过是多分支多同步问题
其实每一对前驱关系都是一个进程同步问题(需要保证一前一后的操作)
因此，
1.要为每一对前驱关系各设置一个同步变量
2.在“前操作”之后对相应的同步变量执行V操作
3.在“后操作”之前对相应的同步变量执行P操作

