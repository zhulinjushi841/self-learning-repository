<!--
 * @Author: Jerome 841682441@qq.com
 * @Date: 2022-12-12 11:38:08
 * @LastEditors: Jerome 841682441@qq.com
 * @LastEditTime: 2022-12-12 17:51:29
 * @FilePath: \操作系统\2.3 处理机调度.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
## 处理机调度
调度的基本概念
当有一堆任务需要处理，但是由于资源有限，这些事情无法同时处理。这就需要确定某种规则来决定处理这些任务的顺序。这就是**调度**研究的问题。
在多道程序系统中，进程的数量往往是多于处理机的个数的。这样不可能会同时并行地处理各个进程。
**1 处理机调度**
就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。

**2 调度的三个层次**
由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定讲作业调入内存的顺序。

**2.1 高级调度(作业调度)**：按照一定原则从外存上处于后备队列的作业中挑选一个(或多个)作业，给他们分配内存等必要资源，并建立起相应的进程(建立PCB),以使得它们获得竞争处理机的权利。

高级调度是辅存(外存)与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但是调出的时机必然是作业运行结束时才调出。

**2.2 中级调度(内存调度)**：在引入了虚拟存储技术之后，可以暂时将不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。
这么做的目的是为了提高内存利用率和系统吞吐量。
暂时调到外存等待的进程状态叫做**挂起**。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个线程的监控、管理。被挂起的进程PCB会被放到挂起队列中。

中级调度(内存调度)，就是要决定将哪个处于挂起状态的进程重新调入内存。
由于一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

**补充知识**
暂时调到外存等待的进程状态为挂起状态(挂起态，suspend)
挂起态又可以进一步被细化分为 就绪挂起、阻塞挂起两种状态
因此，可以将包含有创建态、就绪态、运行态、阻塞态、终止态五状态模型扩充为还包含就绪挂起和阻塞挂起两种状态的七状态模型。
一个处于就绪态的进程，如果此时内存负载比较高，此时可能会将处于就绪态的进程挂起值就绪挂起状态中。当内存空闲或者需要继续执行此进程的时候，就会被激活，重新进入就绪态。

**注意**：挂起和阻塞的区别，两种状态都是暂时不能获得CPU的服务，但是挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。
有的操作系统会将就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不用再将阻塞挂起进程进一步细分为多个队列。

**2.3 低级调度(进程调度)**：其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。
进程调度的频率很高，一般会几十毫秒一次。

**3 进程调度的时机**
进程在操作系统内核程序临界区中不能进行调度与切换。
**补充知识**：临界资源指的是一个时间段内只允许一个进程使用的资源，各进程需要互斥地访问临界资源。
临界区：访问临界资源的那段代码。

内核程序临界区一般是用来访问某种每个内核数据结构的，比如进程的就绪队列(由各就绪进程的PCB组成)

**4 进程调度的方式**
(1)非剥夺调度方式，又称为非抢占方式。
即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，知道该进程终止或者主动要求进入阻塞态。
该方法实现简单，系统开销小，但是无法及时处理紧急任务，适合于早期的批处理系统。

(2)剥夺调度方式，又称为抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或者更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要急迫的那个进程。
可以优先处理更紧急的进程，也可以实现让各个进程按照时间片轮流执行的功能(通过时钟中断)。适合于分时操作系统、实时操作系统。

**5 进程的切换与过程**
狭义的进程调度和进程切换的区别：
狭义的进程调度指的是从就绪队列中选中一个要运行的进程。(这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换)。
进程切换指的是一个进程让出处理机，让另一个进程占用处理机的过程。
广义得到进程调度包含了选择一个进程和进程切换两个步骤。
进程切换的过程主要完成了：
1.对原来运行进程各种数据的保存
2.对新的进程各种数据得到恢复(如程序计数器、程序状态字、各种数据寄存器等处理机线程信息，这些信息一般保存在进程控制块中华)

**注意**；进程切换是有代价的，如果过于频繁的进行进程调度、切换，必然会使得整个系统的效率降低， 并使得系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。

**6 调度算法的评级指标**
调度算法的评级指标包含有CPU利用率，系统吞吐量，周转时间(包含有周转时间、平均周转时间、带权周转时间、平均带权周转时间)，等待时间和相应时间。

**CPU利用率**
由于早期的CPU造价及其昂贵，因此人们会希望CPU尽可能多地工作。
CPU利用率：指的是CPU忙碌的时间占总时间的比例。

**系统吞吐量**
对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。
系统吞吐量：单位时间内完成作业的数量

**周转时间**
对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。
周转时间，指的就是作业被提交给系统开始，到作业完成为止的这段时间间隔。
它包含有四个部分：作业在外存后备队列上等待作业调度(高级调度)的时间、进程在就绪队列上等待进程调度(低级调度)的时间、进程在CPU上执行的时间、进程等待I/O操作完成的时间。后三项在一个作业的整个处理过程中，可能会发生多次。

**等待时间**
计算机用户希望自己的作业尽可能少地等待处理机。
等待时间，指进程/作业处于等待处理机状态之和，等待时间越长，用户满意度越低。
对于进程来说，等待时间就是指进程建立以后等待被服务的时间之和，在等待I/O完成的期间其实进程也是被服务的，所以不计入等待时间。
对于作业来说，不仅要考虑建立进程后的等待时间。还需要加上作业在外村后备队列中等待的时间。
一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。

**响应时间**
对于计算机用户而言，会希望自己提交的请求(比如通过键盘输入了一个调试命令)尽早地开始被系统服务、回应。
相应时间，指的是从用户提交请提取到首次产生响应所用的时间。

**7 调度算法**
调度算法包括先来先服务(FCFS)、短作业优先(SJF)、高响应比优先(HRRN)

**7.1 先来先服务(FCFS, First Come First Service)**
**算法规则**：按照作业/进程到达的先后顺序进行服务
**是否可抢占**：非可抢占式的算法
**优缺点**：
**优点**：公平、算法实现简单
**缺点**：排在长作业(进程)后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好
即FCFS算法对长时间有利，对短时间不利
**是否会导致饥饿(某进程/作业长期得不到服务)**：不会

**FCFS调度算法**就是按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。

**7.2 短作业优先(SJF, Shortest Job First)**
**算法思想**：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间
**算法规则**：最短的作业/进程优先得到服务(所谓最短，是指按照要求服务时间最短)
**用于作业和调度**：即可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先(SPF,Shortest Process First)算法”
**是否可抢占**：SJF和SPF是非抢占式的算法。但是也有抢占式的版本————最短剩余时间优先算法(SRTN，Shortest Remaining Time Next)
**优缺点**：
**优点**：最短的平均等待时间、平均周转时间
**缺点**：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是用户提供的，并不一定真实，不一定能偶做到真正的短作业优先
是否会导致饥饿(某进程/作业长期得不到服务)：会。如果源源不断地有短作业/进程到来，可能会使得长作业/进程长期得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”。

**短作业优先/进程优先调度算法**：每次调度时选择当前已经到达且运行时间最短的作业/进程。
抢占式的短作业优先算法又称为是"最短剩余时间优先算法(SRTN)"
最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度。


**7.3 高响应比优先(HRRN, Highest Response Ratio Next)**
**算法思想**：要综合作业/进程的等待时间和要求服务的时间
**算法规则**：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
响应比的计算=(等待时间+要求服务时间)/要求服务时间
**用于作业和调度**：即可用于作业调度，也可用于进程调度。
**是否可抢占**：非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
**优缺点**：
综合考虑了等待时间和运行时间(要求服务时间)
等待时间相同时，要求服务时间短的优先(SJF的优点)
要求服务时间相同时，等待时间长的优先(FCFS的优点)
对于长时间作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长时间饥饿的问题
**是否会导致饥饿(某进程/作业长期得不到服务)**：不会


**7.4 时间片轮转(RR, Round-Robin)**
**算法思想**：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
**算法规则**：按照各进程到达就绪队列的顺序，轮流让各个进程执行完一个时间片(100ms)。若进城未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。
响应比的计算=(等待时间+要求服务时间)/要求服务时间
**用于作业和调度**：用于进程调度(只有作业放入内存建立了相应的进程后，才能被分配处理机时间片)
**是否可抢占**：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到
**优缺点**：
优点：公平、响应快，适用于分时操作系统
缺点：由于高频率的进程切换，因此有一定的开销；不区分任务的紧急程度
**是否会导致饥饿(某进程/作业长期得不到服务)**：不会

如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法就退化为先来先服务算法，并且会增加进程相应时间，因此时间片不能太大
另一方面，进程调度、切换都是有时间代价的(需要保存和恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花费大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减小，因此时间片也不能太小
一般来说，设计时间片时要让切换进程的开销占比不超过1%。


**7.5 优先级调度算法**
**算法思想**：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
**算法规则**：调度时选择优先级最高的作业/进程
响应比的计算=(等待时间+要求服务时间)/要求服务时间
**用于作业和调度**：既可用于作业调度，也可以用于进程调度。甚至，还会用于I/O调度中
**是否可抢占**：抢占式、非抢占式都有。区别在于：非抢占式只需要在进程主动放弃处理机的时候进行调度即可，而抢占式还需要在就绪队列发生变化时，检查是否会发生抢占
**优缺点**：
优点：用优先级区分紧急程度、重要程度，适用于实时性操作系统。可灵活地调整对各种作业/进程的偏好程度
缺点：若源源不断地有高优先级进程到来，则可能会导致饥饿
**是否会导致饥饿(某进程/作业长期得不到服务)**：会

**非抢占式优先级调度算法**：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度
**抢占式优先级调度算法**：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃时发生调度，另外，当就绪队列发生改变时也需要检查是否会发生抢占

**补充**
就绪队列未必只有一个，可以按照不同优先级来进行组织。另外，也可以把优先级高的进程排在更靠近队头的位置
根据优先级是否可以动态改变，可以将优先级分为静态优先级和动态优先级两种。
静态优先级：创建进程时就确定，之后一直不变
动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级。动态优先级调整的时机：可以从追求公平、提升资源利用率等角度考虑，如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级。如果某进程占用处理机运行了很长时间，则可以适当降低其优先级

**设置各类进程的优先级原则**
通常系统进程高于用户进程
前台进程优先级高于后台进程
操作系统更偏好I/O型进程(或称为I/O繁忙型进程)，原因是I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，就越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。
注：与I/O型进程相对的是计算型进程(或称为CPU繁忙型进程)


**7.6 多级反馈队列调度算法**
**算法思想**：对其他调度算法折中权衡
**算法规则**：1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
2.新进程到达时先进入第1级队列，按照FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。
3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片
**用于作业和调度**：用于进程调度
**是否可抢占**：抢占式算法。在第k级队列的进程运行过程中，若更上级的队列(1~k-1级)中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾
**优缺点**：
对各类型进程相对公平(FCFS的优点)；每个新到达的进程都可以很快得到相应(RR的优点)；短进程只用较少的时间就可以完成(SPF的优点)；不必实现估计进程的运行时间(避免用户造假)；可以灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(扩展：可以将因I/O而阻塞的进程重新放回到原队列，这样I/O型进程就可以保持较高优先级)
**是否会导致饥饿(某进程/作业长期得不到服务)**：会