<!--
 * @Author: Jerome 841682441@qq.com
 * @Date: 2022-12-16 23:51:04
 * @LastEditors: Jerome 841682441@qq.com
 * @LastEditTime: 2022-12-17 00:28:53
 * @FilePath: \操作系统\3.1 内存和内存管理.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
## 内存

**1 内存的基础知识**
内存是用于存放数据的硬件。程序在被执行前需要先放到内存中才能被CPU处理。
在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。为了区分各个程序的数据的存放位置，就需要给内存的存储单元变地址。内存中的每一个“小房间”就是一个存储单元，内存地址从0开始，每个地址都对应于一个存储单元。
具体内存的存储单元的大小需要看计算机是按字节编址还是按字编址。如果是按字节编址，那么每个存储单元大小就是1字节，即1Byte=8bit。
如果字长为16位的计算机按字编址，则每个存储单元大小为1个字，每个字的大小为16个二进制单位。

我们写的代码需要被翻译为CPU可以识别的指令。这些指令会告诉CPU应当去内存的哪个地址存/取数据，这个数据应该做什么样的处理。但是在实际生成机器指令的时候并不知道该进程中的数据会被放到什么位置，因此在编译的过程中生成的指令中一般是使用逻辑地址(相对地址)。

**1.1 逻辑地址vs物理地址**
一般来说，指令中的地址可以采用这样的思想：即在编译时产生的指令只关心“相对地址”，实际放入内存中再按照起始位置就可以得到绝对地址。
**相对地址**又可以被称为**逻辑地址**，**绝对地址**又可以被称为**物理地址**。

**1.2 从写程序到程序运行**
**编译**：由编译程序将用户源代码编译成若干个目标模块(编译就是把高级语言翻译成机器语言)。
**链接**：由连接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，并形成一个完整的装入模块。
**装入(装载)**：由装入程序将装入模块装入内存运行。

**1.3 装入模块装入内存**
装入的三种方式(用三种不同的方法完成逻辑地址到物理地址的转换)：
1.绝对装入
2.静态重定位
3.动态重定位
**绝对装入**
在编译时，如果知道程序将放内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。

在编译、链接后得到的装入模块的指令直接就是用了绝对地址。
绝对装入只适用于单道程序环境。
在程序中使用的绝对地址，可以在编译或者汇编时给出，也可以由程序员直接赋予。通常情况下都是编译或者汇编时再转换为绝对地址。

**静态重定位**
又称作是可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始位置而言的逻辑地址。可以根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行重定位，将逻辑地址变换为物理地址(地址变换是在装入时一次完成的)。

静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。
作业一旦进入内存后，在运行期间就不能够再移动，也不能再申请内存空间。

**动态重定位**
又称作动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才运行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持。

采用动态重定位时允许程序在内存中发生移动。

动态重定义可以将程序分配到不连续的存储区中：在程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存。便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。

**链接的三种方式**
1.**静态链接**：在程序运行之前，现将各目标模块及它们所需的库函数连接成一个完整的可执行文件(装入模块)，之后不再拆开。
2.**装入时动态链接**：将各目标模块装入内存时，边装入边链接的链接方式。
3.**运行时动态链接**：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

**2 内存管理的概念**



